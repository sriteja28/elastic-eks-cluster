image: registry.gitlab.com/gitlab-org/terraform-images/stable:latest

variables:
  TF_ROOT: ${CI_PROJECT_DIR}
  MICRO_SERVICES: ["service1", "service2"]
  CLOUD_PROVIDERS: ["aws"]
  REGIONS: ["us-east-1"]
  ENVIRONMENTS: ["dev"]

stages:
  - lint
  - security-scan
  - build
  - tf-init
  - tf-fmt
  - tf-validate
  - tf-plan
  - tf-apply
  - extract-outputs
  - deploy
  - test
  - tf-destroy

before_script:
  - cd ${TF_ROOT}
  - apk add --no-cache python3 py-pip jq
  - pip3 install awscli

# Terraform linting
lint:
  stage: lint
  script:
    - tflint --init
    - tflint

# Security scanning
security-scan:
  stage: security-scan
  script:
    - tfsec .
    - for service in ${MICRO_SERVICES}; do
        trivy image --exit-code 1 --severity HIGH $CI_REGISTRY_IMAGE/${service}:$CI_COMMIT_SHA;
      done

# Build and push Docker images to ECR
build:
  stage: build
  script:
    - aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin
    - for service in ${MICRO_SERVICES}; do
        docker build -t $CI_REGISTRY_IMAGE/${service}:$CI_COMMIT_SHA ./microservices/${service};
        docker tag $CI_REGISTRY_IMAGE/${service}:$CI_COMMIT_SHA ${ECR_URI}/${service}:$CI_COMMIT_SHA;
        docker push ${ECR_URI}/${service}:$CI_COMMIT_SHA;
      done

# Initialize Terraform
tf-init:
  stage: tf-init
  script:
    - terraform init

# Format Terraform files
tf-fmt:
  stage: tf-fmt
  script:
    - terraform fmt -recursive

# Validate Terraform configuration
tf-validate:
  stage: tf-validate
  script:
    - terraform validate

# Plan Terraform deployment
tf-plan:
  stage: tf-plan
  script:
    - terraform plan -out=tfplan

# Apply Terraform deployment
tf-apply:
  stage: tf-apply
  script:
    - terraform apply -auto-approve tfplan

# Extract Terraform outputs and save as environment variables
extract-outputs:
  stage: extract-outputs
  script:
    - echo "Extracting ECR URIs..."
    - ECR_URIS=$(terraform output -json ecr_repository_uris | jq -r 'to_entries|map("\(.key)=\(.value)")|.[]')
    - echo $ECR_URIS > ecr_uris.env
  artifacts:
    reports:
      dotenv: ecr_uris.env

# Deploy microservices using Helm into their respective namespaces
deploy:
  stage: deploy
  script:
    - source ecr_uris.env
    - for service in ${MICRO_SERVICES}; do
        REPO_URI=$(echo ${!service})
        NAMESPACE="${service}-ns"
        # Create namespace if it doesn't exist
        kubectl get namespace $NAMESPACE || kubectl create namespace $NAMESPACE
        # Replace the placeholder in values.yaml with the actual ECR URI
        sed -i "s|<ECR_URI>|$REPO_URI|g" ./modules/application/helm-charts/microservices/$service/values.yaml
        helm upgrade --install $service ./modules/application/helm-charts/microservices/$service \
            --set image.repository=$REPO_URI \
            --namespace $NAMESPACE;
      done

# Testing with Terratest
test:
  stage: test
  script:
    - go test -v -run TestEKS tests/terratest/test_eks.go
    - go test -v -run TestVPC tests/terratest/test_vpc.go

tf-destroy:
  extends: .tf-job-template
  variables:
    COMMAND: "destroy -auto-approve"
  when: manual